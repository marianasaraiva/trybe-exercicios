# Modelo de docker-compose.yaml
# version: "<VERSÃO-DO-COMPOSE>"
# services: # Definição dos containers
#   <MEU-CONTAINER-1>:
#     image: <MINHA-IMAGEM:VERSÃO> # Exemplo carregando uma imagem já _buildada_
#     # ... outras configurações
#   <MEU-CONTAINER-2>:
#     build: <CAMINHO-DO-DOCKERFILE> # Exemplo gerando uma build a partir de um `Dockerfile`
#     # ... outras configurações
#   <MEU-CONTAINER-N>:
#     image: <MINHA-IMAGEM:VERSÃO>
#     # ... outras configurações

# VERSION : 
# Todo arquivo docker-compose.yaml deve iniciar com a tag version , dessa maneira definimos qual a versão que deverá ser utilizada pelo compose para interpretar o arquivo, evitando assim que o docker-compose.yaml fique incompatível com versões mais recentes do compose .
    # version: '3'

# SERVICES:
# Para o Compose , há o conceito de services , que são os "tipos" dos containers que iremos rodar. Por exemplo, se vamos executar uma API , dizemos que ela é um service . Isso porque com o Compose , podemos escalar nossos apps em vários containers .
# Dessa forma, ao escrevermos nosso arquivo, temos que pensar em services , pois é assim que iremos defini-los. Vamos a um exemplo! Imagine que queremos subir uma aplicação que contém um front-end, um back-end e um banco de dados. Dessa forma, não precisamos ainda pensar em quantos containers teremos, porém, podemos dizer que temos 3 services . Para definir nossos services , utilizamos o parâmetro services . Vamos ver como ficaria esse exemplo em nosso arquivo Compose :
    # version: '3'
    # services:
    #   frontend:
    #     image: mjgargani/compose-example:frontend-trybe1.0
    #   backend:
    #     image: mjgargani/compose-example:backend-trybe1.0
    #   database:
    #     image: mjgargani/compose-example:database-trybe1.0

# RESTART
# No Docker , existem as políticas de reinicialização, que servem para gerenciar se seus containers reiniciarão automaticamente quando o docker for reiniciado ou quando ocorrer algum erro, por exemplo.
# Este comando pode assumir quatro valores:
  # no - Este é o valor padrão assumido pelo Docker e define que o container não irá restartar automaticamente;
  # on-failure - Define que o container será reiniciado caso ocorra alguma falha, apontado pelo exit code diferente de zero;
  # always - Especifica que sempre que o serviço parar, seja por um falha ou porque ele finalizou sua execução, ele irá ser reiniciado; *
  # unless-stopped - Define que o container sempre seja reiniciado, a menos que o Docker em si seja parado (manualmente ou não). No caso de ser interrompido, ele não reinicia nem depois que o daemon do Docker * seja reiniciado.
    # version: '3'
    # services:
    #   frontend:
    #     image: mjgargani/compose-example:frontend-trybe1.0
    #     restart: always
    #   backend:
    #     image: mjgargani/compose-example:backend-trybe1.0
    #     restart: always
    #   database:
    #     image: mjgargani/compose-example:database-trybe1.0
    #     restart: always

# PORTS:
# Uma configuração importante é a porta. Vimos nos conteúdos anteriores como expor e fazer bind delas em nossos containers . No docker-compose.yaml temos o parâmetro ports que se comporta da mesma maneira que o -p do docker container run .
# No nosso exemplo, queremos utilizar a porta 3000 para nosso front-end e a porta 3001 para nosso back-end, ambas fazendo bind para as respectivas portas no host . Dessa forma, nosso arquivo ficará assim:
    # version: '3'
    # services:
    #   frontend:
    #     image: mjgargani/compose-example:frontend-trybe1.0
    #     restart: always
    #     ports:
    #       - 3000:3000
    #   backend:
    #     image: mjgargani/compose-example:backend-trybe1.0
    #     restart: always
    #     ports:
    #       - 3001:3001
    #   database:
    #     image: mjgargani/compose-example:database-trybe1.0
    #     restart: always

# ENVIRONMENT
# Outro parâmetro importante é o environment . Com ele, conseguimos configurar as variáveis de ambiente de nossos containers .
    # version: '3'
    # services:
    #   frontend:
    #     image: mjgargani/compose-example:frontend-trybe1.0
    #     restart: always
    #     ports:
    #       - 3000:3000
    #   backend:
    #     image: mjgargani/compose-example:backend-trybe1.0
    #     restart: always
    #     ports:
    #       - 3001:3001
    #     environment:
    #       - DB_HOST=database
    #   database:
    #     image: mjgargani/compose-example:database-trybe1.0
    #     restart: always

# DEPENDS ON:
# Outro parâmetro importante para garantir a ordem de inicialização e encerramento de services é o depends_on . Com ele, conseguimos estabelecer dependências entre os serviços.
    # version: "3.8"
    # services:
    #   frontend:
    #     image: mjgargani/compose-example:frontend-trybe1.0
    #     restart: always
    #     ports:
    #       - 3000:3000
    #     depends_on:
    #       - "backend"
    #   backend:
    #     image: mjgargani/compose-example:backend-trybe1.0
    #     restart: always
    #     ports:
    #       - 3001:3001
    #     environment:
    #       - DB_HOST=database
    #     depends_on:
    #       - "database"
    #   database:
    #     image: mjgargani/compose-example:database-trybe1.0
    #     restart: always
